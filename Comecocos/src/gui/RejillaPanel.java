/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package gui;

/**
 *
 * @author cristian y rafa
 */
import data.*;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.event.KeyEvent;

public class RejillaPanel extends javax.swing.JPanel {

    private CocosFrame frame;
    int anchoCelda = 15;
    boolean pausa = true;

    /**
     * Creates new form RejillaPanel
     */
    public RejillaPanel() {
        initComponents();
    }

    public RejillaPanel(CocosFrame fr) {
        this();
        frame = fr;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setPreferredSize(new java.awt.Dimension(420, 465));
        setRequestFocusEnabled(false);
        addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseEntered(java.awt.event.MouseEvent evt) {
                formMouseEntered(evt);
            }
        });
        addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyPressed(java.awt.event.KeyEvent evt) {
                formKeyPressed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 420, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 465, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formKeyPressed(java.awt.event.KeyEvent evt) {//GEN-FIRST:event_formKeyPressed

        int siguiente;
       
        if (evt.getKeyCode() == KeyEvent.VK_LEFT) {
            if(frame.getRejilla().choque(frame.getPac(), 0))
            frame.getRejilla().setMovimiento(0);
            
        } else if (evt.getKeyCode() == KeyEvent.VK_RIGHT) {
            if(frame.getRejilla().choque(frame.getPac(), 1))
            frame.getRejilla().setMovimiento(1);

        } else if (evt.getKeyCode() == KeyEvent.VK_UP) {
            if(frame.getRejilla().choque(frame.getPac(), 3))
            frame.getRejilla().setMovimiento(3);
        } else if (evt.getKeyCode() == KeyEvent.VK_DOWN) {
            if(frame.getRejilla().choque(frame.getPac(), 2))
            frame.getRejilla().setMovimiento(2);
        }
        

    }//GEN-LAST:event_formKeyPressed

    private void formMouseEntered(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseEntered
        // TODO add your handling code here:
        requestFocus();
    }//GEN-LAST:event_formMouseEntered

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    
    /**
     * Dibuja la rejilla completa en cada celda dibujará lo que en ese momento se encuentra
     * @param g el gráfico donde dibujará la rejilla.
     */
    public void dibujaRejilla(java.awt.Graphics g) {
        int i, j;
        Rejilla rejilla = frame.getRejilla();
        int xoffset = (getWidth() - rejilla.getAnchura() * anchoCelda) / 2;

        for (i = 0; i < rejilla.getAnchura(); i++) {

            for (j = 0; j < rejilla.getAltura(); j++) {

                if(rejilla.getTipoCelda(i,j)!=Rejilla.V){
                if (rejilla.getTipoCelda(i, j) == Rejilla.B) {
                    g.setColor(Color.BLUE);
                    g.fillRect(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);

                } else if (rejilla.getTipoCelda(i, j) == Rejilla.BUI) {
                    g.setColor(Color.BLUE);
                    g.fillArc(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda+anchoCelda,
                            anchoCelda+15, 90, 180);
                } else if (rejilla.getTipoCelda(i, j) == Rejilla.BDI) {
                    g.setColor(Color.BLUE);
                    g.fillArc(xoffset + i * anchoCelda, j * anchoCelda-anchoCelda, anchoCelda+anchoCelda,
                            anchoCelda+15, 90, 270);
                } else if (rejilla.getTipoCelda(i, j) == Rejilla.BUR) {
                    g.setColor(Color.BLUE);
                    g.fillArc(xoffset + i * anchoCelda-anchoCelda, j * anchoCelda, anchoCelda+anchoCelda,
                            anchoCelda+15, 0, 90);
                } else if (rejilla.getTipoCelda(i, j) == Rejilla.BDR) {
                    g.setColor(Color.BLUE);
                    g.fillArc(xoffset + i * anchoCelda-anchoCelda, j * anchoCelda-anchoCelda, anchoCelda+anchoCelda,
                            anchoCelda+15, 270, 90);
                } else if(rejilla.getTipoCelda(i, j)==Rejilla.C){
                    g.setColor(Color.YELLOW);
                    g.fillOval(xoffset + i * anchoCelda+5, j * anchoCelda+6, anchoCelda/3,
                            anchoCelda/3);
                }else if(rejilla.getTipoCelda(i, j)==Rejilla.E){
                    g.setColor(Color.RED);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                }
            }
            }
        }
    }

    /**
     * La función que se encarga de dibujar todo el gráfico. Dicha función se encarga de dibujar la rejilla 
     * y posterioremente pacman y fantasmas.
     * @param g gráfico
     */
    
    @Override
    protected synchronized void paintComponent(Graphics g) {
        super.paintComponent(g);

       
        g.setColor(Color.BLACK);
        g.fillRect(0, 0, getWidth(), getHeight());
        dibujaRejilla(g);
        
        Fantasma fanRojo=frame.getRojo();
        Fantasma fanAzul=frame.getAzul();
        Fantasma fanRosa=frame.getRosa();
        Fantasma fanNaranja=frame.getNaranja();
        
        dibujaPac(g,frame.getPac().getXOrigen(),frame.getPac().getYOrigen());
        //paintPac(g,frame.getPac().getXOrigen(),frame.getPac().getYOrigen(),frame.getPac().getBoca(),
          //    frame.getRejilla().getMovimiento(),frame.getPac().getIteracion());
        
        dibujarFantasmas(g,fanRojo);
        dibujarFantasmas(g,fanAzul);
        dibujarFantasmas(g,fanRosa);
        dibujarFantasmas(g,fanNaranja);
     

    }
    
    /**
     * Método que dibuja el pac en la celda donde corresponda.
     * @param g gráfico
     * @param xoffset offset calculado previamente
     * @param i posición x
     * @param j posición y
     */
    
    public void dibujaPac(java.awt.Graphics g,int i,int j){
        
        int xoffset = (getWidth() - frame.getRejilla().getAnchura() * anchoCelda) / 2;
        int movimiento=frame.getRejilla().getMovimiento();
        if(movimiento==-1){
        g.setColor(Color.YELLOW);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                    g.setColor(Color.BLACK);
                    g.fillOval(xoffset + i * anchoCelda+10, j * anchoCelda+2, anchoCelda/5,
                            anchoCelda/5);
                            if(frame.getPac().getBoca()){
                                g.setColor(Color.BLACK);
                                int xPoints[]={xoffset+i*anchoCelda+15,xoffset+i*anchoCelda+7,xoffset+i*anchoCelda+15};
                                int yPoints[]={j*anchoCelda+9,j*anchoCelda+9,j*anchoCelda+3};
                                g.fillPolygon(xPoints, yPoints, 3);
                                frame.getPac().setBoca(false);
                            }else{ g.setColor(Color.BLACK);
                                
                                g.drawLine(xoffset+i*anchoCelda+9, j*anchoCelda+8, xoffset+i*anchoCelda+15, j*anchoCelda+8);
                                frame.getPac().setBoca(true);
                            }
        }
        if(movimiento==1){
    g.setColor(Color.YELLOW);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                    g.setColor(Color.BLACK);
                    g.fillOval(xoffset + i * anchoCelda+10, j * anchoCelda+2, anchoCelda/5,
                            anchoCelda/5);
                            if(frame.getPac().getBoca()){
                                g.setColor(Color.BLACK);
                                int xPoints[]={xoffset+i*anchoCelda+15,xoffset+i*anchoCelda+7,xoffset+i*anchoCelda+15};
                                int yPoints[]={j*anchoCelda+9,j*anchoCelda+9,j*anchoCelda+3};
                                g.fillPolygon(xPoints, yPoints, 3);
                                frame.getPac().setBoca(false);
                            }else{ g.setColor(Color.BLACK);
                                
                                g.drawLine(xoffset+i*anchoCelda+9, j*anchoCelda+8, xoffset+i*anchoCelda+15, j*anchoCelda+8);
                                frame.getPac().setBoca(true);
                            }
        }else if(movimiento==0){
        g.setColor(Color.YELLOW);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                    g.setColor(Color.BLACK);
                    g.fillOval(xoffset + i * anchoCelda+2, j * anchoCelda+2, anchoCelda/5,
                            anchoCelda/5);
                            if(frame.getPac().getBoca()){
                                g.setColor(Color.BLACK);
                                int xPoints[]={xoffset+i*anchoCelda,xoffset+i*anchoCelda+7,xoffset+i*anchoCelda};
                                int yPoints[]={j*anchoCelda+9,j*anchoCelda+9,j*anchoCelda+3};
                                g.fillPolygon(xPoints, yPoints, 3);
                                frame.getPac().setBoca(false);
                            }else{ g.setColor(Color.BLACK);
                                
                                g.drawLine(xoffset+i*anchoCelda, j*anchoCelda+8, xoffset+i*anchoCelda+7, j*anchoCelda+8);
                                frame.getPac().setBoca(true);
                            }
        }else if(movimiento==2){
        g.setColor(Color.YELLOW);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                    g.setColor(Color.BLACK);
                    g.fillOval(xoffset + i * anchoCelda+10, j * anchoCelda+8, anchoCelda/5,
                            anchoCelda/5);
                            if(frame.getPac().getBoca()){
                                g.setColor(Color.BLACK);
                                int xPoints[]={xoffset+i*anchoCelda+7,xoffset+i*anchoCelda+7,xoffset+i*anchoCelda+13};
                                int yPoints[]={j*anchoCelda+7,j*anchoCelda+15,j*anchoCelda+15};
                                g.fillPolygon(xPoints, yPoints, 3);
                                frame.getPac().setBoca(false);
                            }else{ g.setColor(Color.BLACK);
                                
                                g.drawLine(xoffset+i*anchoCelda+7, j*anchoCelda+15, xoffset+i*anchoCelda+7, j*anchoCelda+8);
                                frame.getPac().setBoca(true);
                            }
        }else if(movimiento==3){
            g.setColor(Color.YELLOW);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                    g.setColor(Color.BLACK);
                    g.fillOval(xoffset + i * anchoCelda+2, j * anchoCelda+2, anchoCelda/5,
                            anchoCelda/5);
                            if(frame.getPac().getBoca()){
                                g.setColor(Color.BLACK);
                                int xPoints[]={xoffset+i*anchoCelda+9,xoffset+i*anchoCelda+9,xoffset+i*anchoCelda+4};
                                int yPoints[]={j*anchoCelda+10,j*anchoCelda,j*anchoCelda};
                                g.fillPolygon(xPoints, yPoints, 3);
                                frame.getPac().setBoca(false);
                            }else{ g.setColor(Color.BLACK);
                                
                                g.drawLine(xoffset+i*anchoCelda+7, j*anchoCelda, xoffset+i*anchoCelda+7, j*anchoCelda+8);
                                frame.getPac().setBoca(true);
                            }
        
        }else if(movimiento==-1){
        g.setColor(Color.YELLOW);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                    g.setColor(Color.BLACK);
                    g.fillOval(xoffset + i * anchoCelda+10, j * anchoCelda+2, anchoCelda/5,
                            anchoCelda/5);
                            if(frame.getPac().getBoca()){
                                g.setColor(Color.BLACK);
                                int xPoints[]={xoffset+i*anchoCelda+15,xoffset+i*anchoCelda+7,xoffset+i*anchoCelda+15};
                                int yPoints[]={j*anchoCelda+9,j*anchoCelda+9,j*anchoCelda+3};
                                g.fillPolygon(xPoints, yPoints, 3);
                                frame.getPac().setBoca(false);
                            }else{ g.setColor(Color.BLACK);
                                
                                g.drawLine(xoffset+i*anchoCelda+9, j*anchoCelda+8, xoffset+i*anchoCelda+15, j*anchoCelda+8);
                                frame.getPac().setBoca(true);
                            }
        }
        
    }
    
    /**
     * Método auxiliar que dibujaría el pac en cuatro movimientos. Sin uso actualmente
     * y sin finalizar, demasiada complejidad a la hora de dibujar la posición de ojos y boca.
     * @param g
     * @param x
     * @param y
     * @param boca
     * @param movimiento
     * @param iteracion 
     */
    
    public void paintPac(java.awt.Graphics g,int x,int y,boolean boca,int movimiento
            ,int iteracion){
        
        int xoffset = (getWidth() - frame.getRejilla().getAnchura() * anchoCelda) / 2;
        int yoffset=0;
        g.setColor(Color.YELLOW);
        if(movimiento==0){  
        g.fillOval(x * anchoCelda-iteracion*15/4+xoffset, y* anchoCelda+yoffset, anchoCelda,
        anchoCelda);
        g.setColor(Color.BLACK);
        g.fillOval(x * anchoCelda-iteracion*15/4+xoffset+2, y* anchoCelda+yoffset+2, anchoCelda/5,
        anchoCelda/5);
        int xPoints[]={x * anchoCelda-iteracion*15/4+xoffset,x * anchoCelda-iteracion*15/4+xoffset+7,x * anchoCelda-iteracion*15/4+xoffset};
        int yPoints[]={y* anchoCelda+yoffset+9,y* anchoCelda+yoffset+9,y* anchoCelda+yoffset+5};
                                g.fillPolygon(xPoints, yPoints, 3);
        
        }else if(movimiento==1){
            g.fillOval(x * anchoCelda+iteracion*15/4+xoffset, y* anchoCelda+yoffset, anchoCelda,
        anchoCelda);
            g.setColor(Color.BLACK);
        g.fillOval(x * anchoCelda+iteracion*15/4+xoffset+10, y* anchoCelda+yoffset+2, anchoCelda/5,
        anchoCelda/5);
        int xPoints[]={x * anchoCelda+iteracion*15/4+xoffset+15,x * anchoCelda+iteracion*15/4+xoffset+7,x * anchoCelda+iteracion*15/4+xoffset+15};
        int yPoints[]={y* anchoCelda+yoffset+9,y* anchoCelda+yoffset+9,y* anchoCelda+yoffset+5};
                                g.fillPolygon(xPoints, yPoints, 3);
        }else if(movimiento==2){
            g.fillOval(x * anchoCelda+xoffset, y* anchoCelda+iteracion*15/4+yoffset, anchoCelda,
        anchoCelda);
            
        }else if(movimiento==3){
            g.fillOval(x * anchoCelda+xoffset, y* anchoCelda-iteracion+yoffset, anchoCelda,
        anchoCelda);
            
        }
    }
    
    /**
     * Función sin uso actual que eliminaría lo que hubiera en la posición donde le indicásemos
     * pintando una celda negra.
     * @param g
     * @param x
     * @param y
     * @param movimiento
     * @param iteracion 
     */
    
    public void limpiaCelda(java.awt.Graphics g,int x,int y, int movimiento,int iteracion){
        int xoffset = (getWidth() - frame.getRejilla().getAnchura() * anchoCelda) / 2+7;
        int  yoffset=anchoCelda*6+6;
        g.setColor(Color.BLACK);
       if(movimiento==0){  
        g.fillRect(x * anchoCelda-iteracion*15/4+xoffset+18, y* anchoCelda+yoffset, anchoCelda,
        anchoCelda);
        }else if(movimiento==1){
            g.fillRect(x * anchoCelda+iteracion*15/4+xoffset-18, y* anchoCelda+yoffset, anchoCelda,
        anchoCelda);
        }else if(movimiento==2){
            g.fillRect(x * anchoCelda+xoffset, y* anchoCelda+iteracion*15/4+yoffset-18, anchoCelda,
        anchoCelda);
        }else if(movimiento==3){
            g.fillRect(x * anchoCelda+xoffset, y* anchoCelda-iteracion*15/4+yoffset+18, anchoCelda,
        anchoCelda);
        }
    }
    
    /**
     * Dibuja los fantasmas dependiendo del tipo de celda y la posición que nos den.
     * @param g gráfico
     * @param i posición x
     * @param j posición y
     */
    
    public void dibujarFantasmas(java.awt.Graphics g, Fantasma fan){
        int xoffset = (getWidth() - frame.getRejilla().getAnchura() * anchoCelda) / 2;
        int i=fan.getXOrigen();
        int j=fan.getYOrigen();
        
        if(frame.getRejilla().getEstado()){
        if(fan.getTipo()==Rejilla.FR){
                    g.setColor(Color.RED);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                    g.fillRect(xoffset+1 + i * anchoCelda, j * anchoCelda+7, anchoCelda,
                            anchoCelda/2);
                    
                    g.setColor(Color.WHITE);
                    g.fillOval(xoffset + i * anchoCelda+8, j * anchoCelda+2, anchoCelda/3,
                            anchoCelda/3);
                    g.fillOval(xoffset + i * anchoCelda+2, j * anchoCelda+2, anchoCelda/3,
                            anchoCelda/3);
                    g.setColor(Color.BLACK);
                    g.fillOval(xoffset + i * anchoCelda+10, j * anchoCelda+4, anchoCelda/6,
                            anchoCelda/6);
                    g.fillOval(xoffset + i * anchoCelda+4, j * anchoCelda+4, anchoCelda/6,
                            anchoCelda/6);
                    
        } else if(fan.getTipo()==Rejilla.FA){
                    g.setColor(Color.BLUE);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                    g.fillRect(xoffset+1 + i * anchoCelda, j * anchoCelda+7, anchoCelda,
                            anchoCelda/2);
                    
                    g.setColor(Color.WHITE);
                    g.fillOval(xoffset + i * anchoCelda+8, j * anchoCelda+2, anchoCelda/3,
                            anchoCelda/3);
                    g.fillOval(xoffset + i * anchoCelda+2, j * anchoCelda+2, anchoCelda/3,
                            anchoCelda/3);
                    g.setColor(Color.BLACK);
                    g.fillOval(xoffset + i * anchoCelda+10, j * anchoCelda+4, anchoCelda/6,
                            anchoCelda/6);
                    g.fillOval(xoffset + i * anchoCelda+4, j * anchoCelda+4, anchoCelda/6,
                            anchoCelda/6);
        }else if(fan.getTipo()==Rejilla.FP){
                    g.setColor(Color.PINK);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                    g.fillRect(xoffset+1 + i * anchoCelda, j * anchoCelda+7, anchoCelda,
                            anchoCelda/2);
                    
                    g.setColor(Color.WHITE);
                    g.fillOval(xoffset + i * anchoCelda+8, j * anchoCelda+2, anchoCelda/3,
                            anchoCelda/3);
                    g.fillOval(xoffset + i * anchoCelda+2, j * anchoCelda+2, anchoCelda/3,
                            anchoCelda/3);
                    g.setColor(Color.BLACK);
                    g.fillOval(xoffset + i * anchoCelda+10, j * anchoCelda+4, anchoCelda/6,
                            anchoCelda/6);
                    g.fillOval(xoffset + i * anchoCelda+4, j * anchoCelda+4, anchoCelda/6,
                            anchoCelda/6);
        }else if(fan.getTipo()==Rejilla.FN){
                    g.setColor(Color.ORANGE);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                    g.fillRect(xoffset+1 + i * anchoCelda, j * anchoCelda+7, anchoCelda,
                            anchoCelda/2);
                    
                    g.setColor(Color.WHITE);
                    g.fillOval(xoffset + i * anchoCelda+8, j * anchoCelda+2, anchoCelda/3,
                            anchoCelda/3);
                    g.fillOval(xoffset + i * anchoCelda+2, j * anchoCelda+2, anchoCelda/3,
                            anchoCelda/3);
                    g.setColor(Color.BLACK);
                    g.fillOval(xoffset + i * anchoCelda+10, j * anchoCelda+4, anchoCelda/6,
                            anchoCelda/6);
                    g.fillOval(xoffset + i * anchoCelda+4, j * anchoCelda+4, anchoCelda/6,
                            anchoCelda/6);
        }
    }else if(frame.getRejilla().getTipoCelda(i, j)!=Rejilla.V){
        g.setColor(Color.BLUE);
                    g.fillOval(xoffset + i * anchoCelda, j * anchoCelda, anchoCelda,
                            anchoCelda);
                    g.fillRect(xoffset+1 + i * anchoCelda, j * anchoCelda+7, anchoCelda,
                            anchoCelda/2);
                    
                    g.setColor(Color.WHITE);
                    g.fillOval(xoffset + i * anchoCelda+8, j * anchoCelda+2, anchoCelda/3,
                            anchoCelda/3);
                    g.fillOval(xoffset + i * anchoCelda+2, j * anchoCelda+2, anchoCelda/3,
                            anchoCelda/3);
                    g.setColor(Color.BLACK);
                    g.fillOval(xoffset + i * anchoCelda+10, j * anchoCelda+4, anchoCelda/6,
                            anchoCelda/6);
                    g.fillOval(xoffset + i * anchoCelda+4, j * anchoCelda+4, anchoCelda/6,
                            anchoCelda/6);
        }
    }
}
